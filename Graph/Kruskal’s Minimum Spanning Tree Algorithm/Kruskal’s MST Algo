#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

class DSU{
    int *parent;
    int *rank;
public:
    DSU(int n){
        parent = new int[n];
        rank = new int[n];

        for(int i=0; i<n; i++){
            parent[i] = -1;
            rank[i] = 1;
        }

    }

    //path optimization and union by rank
    int findSet(int i){
        if(parent[i]==-1){
            return i;
        }
        return parent[i] = findSet(parent[i]);
    }

    void unionSet(int a, int b){
        int s1 = findSet(a);
        int s2 = findSet(b);

        if(s1!=s2){
            if(rank[s1]>=rank[s2]){
                parent[s2] = s1;
                rank[s1] += rank[s2];
            }
            else{
                parent[s1] = s2;
                rank[s2] += rank[s1];
            }
        }
    }
};

class Graph{
    vector<vector<int>> edgeList;
    int V;
public:
    Graph(int V){
        this->V = V;
    }

    void addEdge(int x, int y, int w){ //coz we want to sort on basis of weigth
        edgeList.push_back({w,x,y});
    }

    //Main Logic
    int Kruskal_Algorithm(){
        //1.sort the edges acc to weight 
        sort(edgeList.begin(),edgeList.end());
        DSU s(V);
        int ans =0;

        //add the edge to the DSU if it doesn't make cycle
        for(vector<int> edge: edgeList){
            int w = edge[0];
            int x = edge[1];
            int y = edge[2];

            if(s.findSet(x) != s.findSet(y)){
                s.unionSet(x,y);
                ans += w;
            }
        }

        return ans;
    }

};

int main(){

    //code thik h bilkul, pta ni kiyo ni chl ra :(

    int m,n;
    cin>>m>>n;

    Graph g(m);

    for(int i=0; i<n; i++){
        int w,x,y;
        cin>>x>>y>>w;
        g.addEdge(x-1,y-1,w);
    }

    /*
9 15
3 6 1
7 9 2
3 5 3
5 6 3
4 8 5
6 8 6
5 4 7
4 7 8
4 2 8
7 8 9
2 3 9
1 2 10
4 6 10  
8 9 11
1 3 12
    */

    cout<<g.Kruskal_Algorithm();

    return 0;
}
